package DAO;

import Util.ConnectionUtil;
import Model.Message;

import java.sql.Connection;

// import 'PreparedStatement' & 'Statement' for executing SQL queries/statements
import java.sql.Statement;
import java.sql.PreparedStatement;

// import 'ResultSet' for navigating in a DB table
import java.sql.ResultSet;

// import 'SQLException' to classify any potential SQL exceptions that arose
import java.sql.SQLException;

// import 'ArrayList' & 'List' classes in order to store collection of data
import java.util.ArrayList; // dynamic appending of elements to ArrayList
import java.util.List;

import org.h2.command.dml.MergeUsing.When;

/**
 * A DAO is a class that mediates the transformation of data between the format of objects in Java to rows in a
 * database. The methods here are mostly filled out, you will just need to add a SQL statement.
 */

public class MessageDAO {
    // ## 3: Our API should be able to process the creation of new messages.
    public Message createMessage(Message msg){
        Connection connection = ConnectionUtil.getConnection();
        try {
            // write/create SQL statement (reflective of 'PreparedStatement' Interface
            /* Recall in 'Message.java' class: "When posting a new message, the id can be generated by the database. 
              In that case, a constructor w/o message_id is needed."" */
            // while inserting, you only need to define the posted_by, message_text, time_posted_epoch values
            String sql = "INSERT INTO message (posted_by, message_text, time_posted_epoch) VALUES (?, ?, ?)";
            PreparedStatement preparedStatement = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);

            //write preparedStatement's setString and setInt methods here.
            // for 1st (?) statement use Message class getter method .getPosted_by() on msg obj to retrieve respective data
            preparedStatement.setInt(1, msg.getPosted_by());
            // for 2nd (?) statement use Message class getter method .getMessage_text() on msg obj to retrieve respective data as well
            preparedStatement.setString(2, msg.getMessage_text());
            // 3rd (?) call .getTime_posted_epoch() method from Message.java class to return time of post & .setLong() converts datatype befitting of above SQL query
            preparedStatement.setLong(3, msg.getTime_posted_epoch());
            // send SQL query to DB
            preparedStatement.executeUpdate();
            ResultSet pkeyResultSet = preparedStatement.getGeneratedKeys();
            // ResultSet.next() method will points to next row/record -- yields false if at end of table
            if(pkeyResultSet.next()){
                // .getLong() method from ResultSet retrieves data from selected column -- 1 (b/c message_id @ column #1 ) & cast to int type
                int newMsgId = (int) pkeyResultSet.getLong(1);
                // create new Message obj record w/ a newly minted message_id attached onto other values making up a 'message' format  
                Message newMessage = new Message(newMsgId, msg.getPosted_by(), msg.getMessage_text(), msg.getTime_posted_epoch());
                
                // return newly created Message row/record
                return newMessage;
            }
        }
        // catch any thrown Exceptions
        catch(SQLException e){
            // console log out Exception messages to CLI
            System.out.println(e.getMessage());
        }
        return null;
    }
    /**
     * TODO: API should be able to retrieve all messages from 'message' table
     * You only need to change the sql String.
     * @return all Books.
     */
    // ## 4: Our API should be able to retrieve all messages.
    public List<Message> getAllMessages(){
        Connection connection = ConnectionUtil.getConnection();
        List<Message> messages = new ArrayList<>();
        try {
            // write/create SQL String 
            String sql = "SELECT * FROM message";
            // Note: Use Wildcard * to shorthand select all columns in 'message' table to show
            // utilizing 'PreparedStatement' interface over 'Statement' interface in executing SQL statement b/c PS pre-compiles SQL & lower likelihood of SQL Injection from User input
            PreparedStatement preparedStatement = connection.prepareStatement(sql);
            ResultSet rs = preparedStatement.executeQuery();
            while(rs.next()){
                Message msg = new Message(
                    rs.getInt("message_id"),
                    rs.getInt("posted_by"),
                    rs.getString("message_text"),
                    rs.getLong("time_posted_epoch"));
                    // rs.getInt("account_id"));
                messages.add(msg);
            }
        }catch(SQLException e){
            System.out.println(e.getMessage());
        }
        // return List of 'messages' w/ Obj type of String (Recall: Lists only take Complex Obj Types -- NOT primitives)
        return messages;
    }
    // ## 5: Our API should be able to retrieve a message by its ID.
    public Message getMessageByMsgId(int msgId){
        Connection connection = ConnectionUtil.getConnection();
        try {
            // write/create SQL query String
            String sql = "SELECT * FROM message WHERE message_id = ?";
            
            PreparedStatement preparedStatement = connection.prepareStatement(sql);

            //write preparedStatement's setString and setInt methods here.
            preparedStatement.setInt(1, msgId);    // at 1st (?) set to argument 'id'
            // execute/send SQL queries to DB
            ResultSet rs = preparedStatement.executeQuery();
            // while ResultSet is not empty (more records) to point to next record/row
            while(rs.next()){
                // create an instance of Message obj -- retrieve from Message obj
                Message msg = new Message(
                    rs.getInt("message_id"),
                    rs.getInt("posted_by"),
                    rs.getString("message_text"),
                    rs.getLong("time_posted_epoch"));
                // return 'msg' corresponding to given arg 'id ('message_id') 
                return msg;  // -- use this change this method to type 'Message'
                // return msg.message_text;    // returns actual content of message in String format
            }
        // if any Exceptions are caught
        }catch(SQLException e){
            // console log out to terminal
            System.out.println(e.getMessage());
        }
        // otherwise return null status code 404 NOT FOUND -- if data not in DB
        return null;
    }
    // ## 6: Our API should be able to delete a message identified by a message ID.
    // similar to UPDATE functionality below but parameter only require msgId
    public void deleteMessagebyMsgId(int msgId){
        // establish a connection to database
        Connection connection = ConnectionUtil.getConnection();
        try {
            // Write SQL logic here
            // SQL String query to DELETE record from 'message' table
            String sql = "DELETE FROM message WHERE message_id = ?";
            // best practice to use 'PreparedStatement' interface as lower chances of SQL Injection from client-side affecting backend database
            PreparedStatement preparedStatement = connection.prepareStatement(sql);

            // write PreparedStatement setString and setInt methods here.
            // preparedStatement.setInt(1, msg.getPosted_by());
            // preparedStatement.setString(2, msg.getMessage_text());
            // preparedStatement.setLong(3, msg.getTime_posted_epoch());
        
            // preparedStatement.setInt(4, msgId);

            // preparedStatement.setString(1, msg.getMessage_text());
            preparedStatement.setInt(1, msgId);

            preparedStatement.executeUpdate();
        }catch(SQLException e){
            System.out.println(e.getMessage());
        }
    }
    // ## 7: Our API should be able to update a message text identified by a message ID.
    /* NOTICE: UPDATE method in DAO is of 'void' return type (but in Service is 'Message' obj return type)
     * @param msgId a message ID.
     * @param msg is a message object & the message object does not contain a message ID.
     */
    public void updateMessageByMsgId(int msgId, Message msg){
        Connection connection = ConnectionUtil.getConnection();
        try {
            // Write SQL logic here
            // probably should UPDATE by 'message_id'
            String sql = "UPDATE message SET posted_by = ?, message_text = ?, time_posted_epoch = ? WHERE message_id = ?";
            // String sql = "UPDATE message SET message_text = ? WHERE message_id = ?";
            // best practice to use 'PreparedStatement' interface in creation of SQL query as it pre-compiles code b4-hand -- lessen chance of SQL Injection working
            PreparedStatement preparedStatement = connection.prepareStatement(sql);

            // write PreparedStatement setString and setInt methods here.
            preparedStatement.setInt(1, msg.getPosted_by());
            preparedStatement.setString(2, msg.getMessage_text());
            preparedStatement.setLong(3, msg.getTime_posted_epoch());
            preparedStatement.setInt(4, msgId);

            // preparedStatement.setInt(5, msgId);

            /* Nevermind from the test results --- actually want to display all 4 columns */
            // preparedStatement.setString(1, msg.getMessage_text());
            // preparedStatement.setInt(2, msgId);

            preparedStatement.executeUpdate();

            /* testing out creating SQL query using 'Statement' interface */
            // Statement stmt = connection.createStatement();
            // String sql = "UPDATE message SET posted_by = ?, message_text = ?, time_posted_epoch = ? WHERE message_id = ?";
            // ResultSet rs = stmt.executeQuery(sql);
            // stmt.executeQuery(sql);
        }catch(SQLException e){
            System.out.println(e.getMessage());
        }
    }
    // ## 7a) Helper function/method to check if 'message_id' already exists in 'message' table
    public boolean msgCheckMsgId(int msgId){
        Connection connection = ConnectionUtil.getConnection();
        try {
            // write/create SQL query String
            String sql = "SELECT * FROM message WHERE message_id = ?";
            
            PreparedStatement preparedStatement = connection.prepareStatement(sql);

            // write preparedStatement's setString and setInt methods here for parameterized query placeholder (?) above
            preparedStatement.setInt(1, msgId);    // set 1st (?) to arg's 'msgId'
            // execute/send SQL queries to DB
            ResultSet rs = preparedStatement.executeQuery();
            // check if ResultSet is not empty -- contains records to move cursor to (same as while(rs.next(){ return true; } just more direct))
            if(rs.next()){  
                // 'message_id' already exists in the DB table
                return true;
            }
        // if any Exceptions are caught
        }catch(SQLException e){
            // console log out to terminal
            System.out.println(e.getMessage());
        }
        // otw return false indicates username DNE in DB table
        return false;
    }
    // ## 7b) OMITTED --- could just use ##5 getMessageByMsgId()
    // public Message getUpdatedMsgRecordById(int msgId){
    //     Connection connection = ConnectionUtil.getConnection();
    //     try {
    //         // write/create SQL query String
    //         String sql = "SELECT * FROM message WHERE message_id = ?";
            
    //         PreparedStatement preparedStatement = connection.prepareStatement(sql);

    //         //write preparedStatement's setString and setInt methods here.
    //         preparedStatement.setInt(1, msgId);    // at 1st (?) set to argument 'id'
    //         // execute/send SQL queries to DB
    //         ResultSet rs = preparedStatement.executeQuery();
    //         // while ResultSet is not empty (more records) to point to next record/row
    //         while(rs.next()){
    //             // create an instance of Message obj -- retrieve from Message obj
    //             Message msg = new Message(
    //                 rs.getInt("message_id"),
    //                 rs.getInt("posted_by"),
    //                 rs.getString("message_text"),
    //                 rs.getLong("time_posted_epoch"));
    //             // return 'msg' corresponding to given arg 'id ('message_id') 
    //             return msg;  // -- use this change this method to type 'Message'
    //             // return msg.message_text;    // returns actual content of message in String format
    //         }
    //     // if any Exceptions are caught
    //     }catch(SQLException e){
    //         // console log out to terminal
    //         System.out.println(e.getMessage());
    //     }
    //     // otherwise return null status code 404 NOT FOUND -- if data not in DB
    //     return null;
    // }

    /* Aside: From provided path URL endpoint --- maybe move this method to 'AccountDAO' class */
    // ## 8: Our API should be able to retrieve all messages written by a particular user.
    /* Note: This method should probably be of List type as will be returning a list of all messages by an User */
    public List<Message> getAllMessagesByUserId(int userId){    // 'userId' is just a placeholder (for some 'account_id')
        // connect to 'Message' table in database
        Connection connection = ConnectionUtil.getConnection();
        // declare an empty List obj of Message obj type
        List<Message> messagesByUser = new ArrayList<>();
        // try-catch block for error-handling
        try {
            // write/create SQL query String --- "posted_by" field is a FOREIGN KEY REFERENCES to "account_id" in 'account' table
            String sql = "SELECT * FROM message WHERE posted_by = ?";
            // create 'PreparedStatement' obj to send above parameterized SQL statement to DB
            PreparedStatement preparedStatement = connection.prepareStatement(sql);
            // PreparedStatement.setInt() method to set above (?) placeholder w/ to input arg's 'userId' value
            preparedStatement.setInt(1, userId);    
            // execute/send SQL queries to DB
            ResultSet rs = preparedStatement.executeQuery();
            // while ResultSet is not empty (records available, move cursor to next)
            while(rs.next()){
                // create an instance of Message obj -- retrieve from Message obj
                Message msg = new Message(
                    rs.getInt("message_id"), 
                    rs.getInt("posted_by"),
                    rs.getString("message_text"),
                    rs.getLong("time_posted_epoch"));
                // invoke .add() method to append current 'msg' into earlier declared List collection
                messagesByUser.add(msg);
            }
        // if any Exceptions are caught
        }catch(SQLException e){
            // console log out to terminal
            System.out.println(e.getMessage());
        }
        // return whole collection of messages labeled under this userId
        return messagesByUser;
    }
    
}
